{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2024-10-31T12:44:37.539-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2024-10-31T12:47:23.82-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "uCBeRSriDQCuQOq6C2HBGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "#BrActor\r\nactor is the ancestor of aptitude and viewModel.\r\n\r\nWhen an actor (look or model) is not attached to the element it can not send or receive events\r\n\r\nCommunication between element is based on event.\r\n\r\nYou don’t have to create view models. The logic is like this: ha, we use this specific composition of elements often. Let’s give it a name and put in Brick. For example button with a label. It is annoying to build one every time from elements. So we provide it in Brick. \r\n\r\nThere is a \"widget\" Tab when inspecting an element. It shows the composition of the widget including all aptitudes it is using"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2024-10-31T13:33:44.792-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-04-14T11:24:47.133-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "2J8J9SriDQC2uFj5C2HBGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Like a trait, a talent represents a set of methods that constitute part of the behavior of an object. Unlike traits, talents can be acquired (or lost) dynamically. When a talent is\napplied to an object, no other instance of the object’s class are affected. Talents may be composed of\nother talents, however, as with traits, the composition order is irrelevant. Conflicts must be explicitly\nresolved ([source](https://scg.unibe.ch/archive/papers/Ress12eTalentsSPE.pdf))"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2024-10-31T12:47:16.421-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2024-10-31T12:47:17.331-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "oHXWTiriDQCunTn9C2HBGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "A widget can be made of multiple aptitude and multiple Widget model, and the pattern used is best described by:"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2024-10-31T12:43:28.864-04:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2024-10-31T12:47:11.851-04:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "ADtGQSriDQCuHP3dC2HBGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "#Actor role pattern:\r\n\r\nAdapt an object to different client’s needs through transparently attached role objects, each one representing a role the object has to play in that client’s context. The object manages its role set dynamically. By representing roles as individual objects, different contexts are kept separate and system configuration is simplified\r\n\r\nAn object-oriented system is typically based on a set of key abstractions. Each key abstraction is modeled by a corresponding class in terms of abstract state and behavior. This usually works fine for the design of smaller applications. However, once we want to scale up the system into an integrated suite of applications, we have to deal with different clients that need context-specific views on our key abstractions.\r\n\r\nIntegrating several context-specific views in the same class will most likely lead to key abstractions with bloated interfaces. Such interfaces are difficult to understand and hard to maintain. Unanticipated changes cannot be handled gracefully and will trigger lots of recompilation. Changes to a client-specific part of the class interface are likely to affect clients in other subsystems or applications as well.\r\n\r\nThe Role Object pattern suggests to model context-specific views of an object as separate **role objects** which are dynamically attached to and removed from the **core object**.\r\n\r\nThe Actor Role Object pattern is usefull, if\r\n- you want to handle a key abstraction in different contexts and you do not want to put the resulting context specific interfaces into the same class interface.\r\n- you want to handle the available roles dynamically so that they can be attached and removed on demand, that is  at runtime, rather than fixing them statically at compile-time.\r\n- you want to treat the extensions transparently and need to preserve the logical object identity of the resulting object conglomerate.\r\n- you want to keep role/client pairs independent from each other so that changes to a role do not affect clients that are not interested in that role.\r\n[source](https://hillside.net/plop/plop97/Proceedings/riehle.pdf)"
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2024-10-31T12:43:33.798-04:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2024-10-31T12:43:33.798-04:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : "Actor pattern"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "200c4641-2ae2-0d00-ae1b-6a350b61c118"
	}
}