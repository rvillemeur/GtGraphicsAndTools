note morph



• Morph is a superclass of graphical objects; it has methods that let those objects respond to events and display themselves.
• All morphs have bounds (rectangles on the screen), and can have submorphs.
• The world (the screen or page) is itself a morph. This gives you the basic model for a scene graph displayed on the screen.
• A hand object, shown as the cursor (and also part of the world), can pick up other objects and drop them elsewhere, thus effecting not only motion but also changes in the structure of the scene graph. The hand is also the source of user event messages such as mouseDown: and mouseMove:.
• User events such as mouseDown: are passed as messages from the screen, down through the scene graph, to the frontmost morph that contains the location of the event.
• Morphs typically define methods that respond to user input events like mouseDown:, or to the passage of time through a tick message from the world.
• When a morph’s position or appearance changes, a changed message causes the Morphic display system to update the screen efficiently, and without flashing.
• Both normal screen changes and animations are handled by a simple iterative kernel:
    forever do:
    detect and dispatch user events, such as mouseDown:, mouseMove:
    run step methods defined for any morphs,
    compute the affected screen area, and update it using double buffering
(source: the evolution of smalltalk.pdf)

# coordinate systems:
A morph has two coordinate system:
- from the outsite world
- from itself, its bounds
Accesssible in the geometry protocol
For example, if you specify a point directly, Morph will position it in the world.
Bounds are recalculated when we move the morph, and coordinate associated with it
are recalculated accordingly.

Morphic:
Un Morph est définis par son "bounds", soit le rectangle délimitant son espace.
http://wiki.squeak.org/squeak/morphic
https://wiki.squeak.org/squeak/2141



Pour créer un nouveau widget:
- drawOn: dessine le nouveau widget.
- containsPoint: pour définir la place effectivement occupé à l'ecran


Gestion de la souris et des évènement.
- handleMouseDown: et 
    - mouseDown:; mouseUp:

- handleMouseOver:
    - mouseEnter: et mouseLeave:

- handleKeyStroke

Pour combiner les Morph:
- addMorph: and all method in protocol 'submorphs-add/remove'
- position, dans le protocol geometry
Note that the geometry protocol is used to position element inside a Morph.
It can be used as well in the drawOn: message, so it used either for drawing
or for position Morph when we combine them.
- layout policy: https://wiki.squeak.org/squeak/2141


Animation:
- step and StepTime

Drag&Drop:

Get Form generated by Morph: AthensHello new imageForm  

When you open a Morph with the message openInWorld, it'll add itself to the 
global world Morph: `aWorld addMorph: self.`


Exemple de construction de fenêtre morphic avec modèle: FontChooserMorph et FontChooser
Exemple de morph affiché dynamiquement: CalendarMorph on: '2020-01-21' asDate
Exemple de morph construit par aggregation de morph: CheckboxMorph  new openInWorld 
- on dérive d'un morph, et on ajoute les nouveaux morph intéressant.


self bounds corner - self bounds origin
bounds is a Rectangle object. As such, you can find its coordinate, 
either relative from Pharo world: bounds origin, bounds corner,
or by itself, going from 0@0 to bounds extend


Canvas utilisé par défaut: FormCanvas
Athen dessine dans une image, qu'il envoie ensuite dans le canvas.


Morph subclass: #AthensDemoMorph

drawOn: aCanvas

self halt.
	self render.

	aCanvas
		drawImage: surface asForm at: self bounds origin


asForm
	"create a form and copy an image data there"
	self checkSession.
	self flush.
 	^ (AthensCairoSurfaceForm extent: (self width@(self height)) depth: 32 bits: id)
		surface: self;
		yourself


Morph a trop de responsabilité:
- layout de sous-morph (protocol geometry)
- styling 
- gestion des menus du World


HandMorph -> souris.

WorldMorph doOneCycle -> permet de rafraichir le monde.
Va parcourir les sous-morph qui composent le monde, et va les dessiner, en utilisant le canvas par défaut: FormCanvas

Le canvas va utiliser la classe Form, qui est un espace rectangulaire pour mettre une image.
La classe Form utilise ensuite BitBlt pour envoyer son dessin vers l'écran
